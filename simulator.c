/*
OVERVIEW
    Simulate cars
        A simulated car recieves a random license plate (sometimes on the list, sometimes not)
        and queues up at a random entrace to the car park, triggering an LPR when it reaches
        the front of the queue.

        After triggering the LPR (license plate reader), the simulated car will watch the
        digital sign. If the sign contains a number, it will keep note of that number
        (the level where the car has been instructed to park) and then wait for the boom
        gate to open. If the sign contains any other character, the simulated car will just
        leave the queue and drive off, disappearing from the simulation

        After the boom gate opens, the car will drive to the level it was instructed to drive to,
        triggering the level LPR in the process

        The car will then park for a random amount of time

        After the car has finished parking, it will leave, setting off the level LPR again.
        It will then drive towards a random exit. Upon reaching that exit, it will set off the
        exit LPR and wait for the boom gate to open. Once the boom gate is open, it will leave
        the car park and disappear from the simulation.

    Simulate boom gates
        Boom gates take a certain amount of time to open and close. Once the manager has instructed
        a closed boom gate to open or an open boom gate to close, the simulator's job is to wait for
        a small amount of time before putting the boom gate into the open/closed state.

    Simulate temperature
        Each level of the car park has a temperature sensor, sending back the current temperature
        (in degrees celsius). THe simulator will frequently update these values with reasonable
        random values. The simulator should also be able to simulate a fire by generating higher
        values, in order to test / demonstrate the fire alarm system.

TIMINGS
    Every 1-100ms, a new car will be generated by the simulator with
    a random license plate, and will start moving towards a random entrance
        Check page 4 of brief for specifics about functions

    Once a car reaches the front of the queue, it will wait 2ms before
    triggering the entrance LPR

    Boom Gates take 10ms to fully open and close

    After the boom gate is open, the car takes another 10ms to drive
    to its parking space (which will then trigger the level LPR for the
    first time)

    Once parked, the car will wait 100-10000ms before departing the level
    (and triggering the level LPR of the second time)

    It then takes the car a further 10ms to drive to a random exit and
    trigger the exit LPR.

    Every 1-5ms the temperature on each level will change to a random value

MEMORY
    The simulator must create a shared memory segment named PARKING.

    The segment is 2920 bytes in size and must be created every time the
    program runs (overwrite existing)
*/
#include <fcntl.h>
#include <pthread.h>
#include <semaphore.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>

#include "./header.h"

#define SHARE_NAME "PARKING"
#define SHARE_SIZE 2920
/* number of threads used to service requests */
#define NUM_HANDLER_THREADS 10

// global variables
int shm_fd;
void *ptr;

int generate_id;
int thread_id;

pthread_t *generate_car;
pthread_t *simulate_car;

const char charset[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
const char number[] = "1234567890";
char temp[6];
char *license_plate[100];

// attributes for mutex and cond
pthread_mutexattr_t m_shared;
pthread_condattr_t c_shared;

pthread_mutex_t mutex_car;
pthread_cond_t cond_car;

car_t *cars = NULL;     /* head of linked list of requests. */
car_t *last_car = NULL; /* pointer to last request.         */

int num_car = 0;

// initalize hash tables for storing plates from txt
bool store_plates() {
    FILE *f = fopen("plates.txt", "r");
    int i = 0;
    // put value in array char
    while (fgets(temp, 8, f)) {
        temp[strcspn(temp, "\n")] = 0;
        license_plate[i] = malloc(6);
        strcpy(license_plate[i], temp);
        i++;
    }
    fclose(f);
    return EXIT_SUCCESS;
}

static char *rand_string(char *str, size_t size) {
    if (size) {
        --size;
        for (size_t n = 0; n < 3; n++) {
            int key = rand() % (int)(sizeof number - 1);
            str[n] = number[key];
        }
        for (size_t n = 0; n < 3; n++) {
            int key = rand() % (int)(sizeof charset - 1);
            str[n + 3] = charset[key];
        }
    }
    return str;
}

// random license plate
char *rand_string_alloc(size_t size) {
    char *s = malloc(size);
    if (s) {
        rand_string(s, size);
    }
    return s;
}

char *random_cars(bool flag) {
    // create car
    char *rand_license = malloc(sizeof(char[6]));
    // random license
    // if flag false, create a random license plate
    if (flag == false) {
        char *license = rand_string_alloc(6);
        strcpy(rand_license, license);
    }
    // if true, get the license plate that is allowed
    else {
        int i = rand() % 100;
        char *license = license_plate[i];
        strcpy(rand_license, license);
    }

    return rand_license;
}

void add_car(char license[6], int exit_id, char lv,
             pthread_mutex_t *p_mutex,
             pthread_cond_t *p_cond_var) {
    car_t *a_car; /* pointer to newly added request.     */

    /* create structure with new request */
    a_car = (struct car *)malloc(sizeof(struct car));
    if (!a_car) { /* malloc failed?? */
        fprintf(stderr, "add_car: out of memory\n");
        exit(1);
    }

    strcpy(a_car->license, license);
    a_car->exit_id = exit_id;
    a_car->lv = lv;

    /* lock the mutex, to assure exclusive access to the list */
    pthread_mutex_lock(p_mutex);

    /* add new car to the end of the list, updating list */
    /* pointers as required */
    if (num_car == 0) { /* special case - list is empty */
        cars = a_car;
        last_car = a_car;
    } else {
        last_car->next = a_car;
        last_car = a_car;
    }

    /* increase total number of pending cars by one. */
    num_car++;

    /* unlock mutex */
    pthread_mutex_unlock(p_mutex);

    /* signal the condition variable - there's a new request to handle */
    pthread_cond_signal(p_cond_var);
}

struct car *get_car() {
    struct car *a_car; /* pointer to car.                 */

    if (num_car > 0) {
        a_car = cars;
        cars = a_car->next;
        if (cars == NULL) { /* this was the last car on the list */
            last_car = NULL;
        }
        /* decrease the total number of pending cars */
        num_car--;
    } else { /* cars list is empty */
        a_car = NULL;
    }

    /* return the car to the caller. */
    return a_car;
}

void handle_a_car(car_t *car) {
    int lv_addr = ((car->lv - 49) * sizeof(lv_t)) + 2400;
    LPR_t *lv_lpr = ptr + lv_addr;

    // take 10 ms to get to the lv
    usleep(10 * 1000);

    // signal the lv lpr for the second time to leave
    strcpy(lv_lpr->license, car->license);
    // signal the lv lpr for the first time to enter
    pthread_cond_signal(&lv_lpr->c);

    // park there for random time
    int rd_time = (100 + (rand() % (900))) * 1000;
    printf("%d\n", rd_time);
    usleep(rd_time);

    // signal the lv lpr for the second time to leave
    strcpy(lv_lpr->license, car->license);
    pthread_cond_signal(&lv_lpr->c);

    // signal the lpr at the exit to leave
    // the car is at the exit
    int ex_addr = (car->exit_id * sizeof(exit_t)) + 1440;
    LPR_t *ex_lpr = ptr + ex_addr;
    strcpy(ex_lpr->license, car->license);
    pthread_cond_signal(&ex_lpr->c);
}

void *simulate_car_handler(void *arg) {
    car_t *a_car;

    pthread_mutex_lock(&mutex_car);

    // do forever
    for (;;) {
        if (num_car > 0) {
            a_car = get_car();
            if (a_car) {
                pthread_mutex_unlock(&mutex_car);
                handle_a_car(a_car);
                free(a_car);
                pthread_mutex_lock(&mutex_car);
            }
        } else {
            // wait for cars
            pthread_cond_wait(&cond_car, &mutex_car);
        }
    }
}

void *generate_car_handler(void *arg) {
    bool flag = true;
    // do forever
    for (;;) {
        // create a car
        char *rand_license = random_cars(flag);
        // assign cars to the entrance
        int floor = rand() % (int)(5);
        // int floor = 0;
        int exit_id = rand() % (int)(5);
        // int exit_id = 0;
        struct LPR *lpr = ptr + (sizeof(en_t) * floor);
        // lock the mutex
        pthread_mutex_lock(&lpr->m);
        printf("#%s is at the entrance %d\n", rand_license, floor + 1);
        // the car is at the entrance
        strcpy(lpr->license, rand_license);
        // wait 2ms for the lpr entrance to read
        usleep(2 * 1000);
        // signal the lpr entrance to read
        pthread_cond_signal(&lpr->c);

        pthread_mutex_unlock(&lpr->m);

        info_sign_t *ist = ptr + (sizeof(en_t) * floor) + 192;
        boomgate_t *bg = ptr + (sizeof(en_t) * floor) + 96;

        pthread_mutex_lock(&ist->m);
        // wait for the ist
        pthread_cond_wait(&ist->c, &ist->m);
        if (ist->s == 'X') {
            printf("ist says: %c\n", ist->s);
            // this car is removed
            free(rand_license);
            flag = !flag;
            pthread_mutex_unlock(&ist->m);

        } else if (ist->s == 'F') {
            printf("ist says: %c\n", ist->s);
            // this car is removed
            free(rand_license);
            flag = !flag;
            pthread_mutex_unlock(&ist->m);

        } else {
            printf("this car can be parked on level %c! \n", ist->s);
            pthread_mutex_unlock(&ist->m);

            pthread_mutex_lock(&bg->m);
            printf("Entrance %d is raising the boomgate!\n", floor + 1);
            // raising for 10 ms
            bg->s = 'R';
            usleep(10 * 1000);
            pthread_cond_signal(&bg->c);

            // wait for the manager tells to close
            pthread_cond_wait(&bg->c, &bg->m);

            // lowering for 10 ms
            printf("Entrance %d is lowering the boomgate!\n", floor + 1);
            bg->s = 'L';
            usleep(10 * 1000);
            // signal finish lowering
            pthread_cond_signal(&bg->c);

            // wait for the gate to fully close
            pthread_cond_wait(&bg->c, &bg->m);
            add_car(rand_license, exit_id, ist->s, &mutex_car, &cond_car);

            // this car is removed
            free(rand_license);
            flag = !flag;

            pthread_mutex_unlock(&bg->m);
        }

        // sleep(1);
        usleep((rand() % 100) * 1000);
    }
}

int main(int argc, char **argv) {
    // delete the segment if exists
    if (shm_fd > 0) {
        shm_unlink(SHARE_NAME);
    }
    // get the shared objects
    shm_fd = shm_open(SHARE_NAME, O_CREAT | O_RDWR, S_IRWXU);
    // set the size
    ftruncate(shm_fd, SHARE_SIZE);
    // get the address and save it in the pointer
    ptr = (void *)mmap(0, SHARE_SIZE, PROT_WRITE | PROT_READ, MAP_SHARED, shm_fd, 0);

    // store plates
    store_plates();

    // make sure the pthread mutex is sharable by creating attr
    pthread_mutexattr_init(&m_shared);
    pthread_mutexattr_setpshared(&m_shared, PTHREAD_PROCESS_SHARED);
    // make sure the cthread mutex is sharable by creating attr
    pthread_condattr_init(&c_shared);
    pthread_condattr_setpshared(&c_shared, PTHREAD_PROCESS_SHARED);

    // initialize mutexes and condition variables
    pthread_mutex_init(&mutex_car, &m_shared);
    pthread_cond_init(&cond_car, &c_shared);

    // create 5 entrance, exit and level lpr
    for (int i = 0; i < 5; i++) {
        // address for entrance, exits and levels; and store it in *en
        int en_addr = i * sizeof(en_t);
        int ex_addr = i * sizeof(exit_t) + 1440;
        int lv_addr = i * sizeof(lv_t) + 2400;

        // lpr
        LPR_t *en_lpr = ptr + en_addr;
        LPR_t *ex_lpr = ptr + ex_addr;
        LPR_t *lv_lpr = ptr + lv_addr;

        // boomgate
        boomgate_t *en_bg = ptr + en_addr + 96;
        boomgate_t *ex_bg = ptr + ex_addr + 136;

        // ist
        info_sign_t *ist = ptr + en_addr + 192;
        // mutexes and cond for lpr
        pthread_mutex_init(&en_lpr->m, &m_shared);
        pthread_mutex_init(&ex_lpr->m, &m_shared);
        pthread_mutex_init(&lv_lpr->m, &m_shared);

        pthread_cond_init(&en_lpr->c, &c_shared);
        pthread_cond_init(&ex_lpr->c, &c_shared);
        pthread_cond_init(&lv_lpr->c, &c_shared);

        // mutexes and cond for bg
        pthread_mutex_init(&en_bg->m, &m_shared);
        pthread_mutex_init(&ex_bg->m, &m_shared);

        pthread_cond_init(&en_bg->c, &c_shared);
        pthread_cond_init(&ex_bg->c, &c_shared);

        // mutexes and cond for ist
        pthread_mutex_init(&ist->m, &m_shared);
        pthread_cond_init(&ist->c, &c_shared);
    }

    *(char *)(ptr + 2919) = 1;

    // wait until the manager change the process of then we can stop the manager
    while ((*(char *)(ptr + 2919)) == 1) {
    };

    generate_car = malloc(sizeof(pthread_t) * 1);
    simulate_car = malloc(sizeof(pthread_t) * NUM_HANDLER_THREADS);

    generate_id = 1;

    pthread_create(generate_car, NULL, generate_car_handler, (void *)&generate_id);
    // }

    thread_id = 1;
    // create 1 threads for simulating the car
    for (int i = 0; i < NUM_HANDLER_THREADS; i++) {
        pthread_create(simulate_car, NULL, simulate_car_handler, (void *)&thread_id);
        thread_id++;
    }

    sleep(20);
    *(char *)(ptr + 2919) = 1;

    // destroy the segment
    if (munmap(ptr, SHARE_SIZE) != 0) {
        perror("munmap() failed");
    }
    if (shm_unlink(SHARE_NAME) != 0) {
        perror("shm_unlink() failed");
    }

    free(generate_car);
    free(simulate_car);

    // destroy mutex and cond attributes
    pthread_mutexattr_destroy(&m_shared);
    pthread_condattr_destroy(&c_shared);

    return 0;
}
