/*
OVERVIEW
    Simulate cars
        A simulated car recieves a random license plate (sometimes on the list, sometimes not)
        and queues up at a random entrace to the car park, triggering an LPR when it reaches
        the front of the queue.

        After triggering the LPR (license plate reader), the simulated car will watch the
        digital sign. If the sign contains a number, it will keep note of that number
        (the level where the car has been instructed to park) and then wait for the boom
        gate to open. If the sign contains any other character, the simulated car will just
        leave the queue and drive off, disappearing from the simulation

        After the boom gate opens, the car will drive to the level it was instructed to drive to,
        triggering the level LPR in the process

        The car will then park for a random amount of time

        After the car has finished parking, it will leave, setting off the level LPR again.
        It will then drive towards a random exit. Upon reaching that exit, it will set off the
        exit LPR and wait for the boom gate to open. Once the boom gate is open, it will leave
        the car park and disappear from the simulation.

    Simulate boom gates
        Boom gates take a certain amount of time to open and close. Once the manager has instructed
        a closed boom gate to open or an open boom gate to close, the simulator's job is to wait for
        a small amount of time before putting the boom gate into the open/closed state.

    Simulate temperature
        Each level of the car park has a temperature sensor, sending back the current temperature
        (in degrees celsius). THe simulator will frequently update these values with reasonable
        random values. The simulator should also be able to simulate a fire by generating higher
        values, in order to test / demonstrate the fire alarm system.

TIMINGS
    Every 1-100ms, a new car will be generated by the simulator with
    a random license plate, and will start moving towards a random entrance
        Check page 4 of brief for specifics about functions

    Once a car reaches the front of the queue, it will wait 2ms before
    triggering the entrance LPR

    Boom Gates take 10ms to fully open and close

    After the boom gate is open, the car takes another 10ms to drive
    to its parking space (which will then trigger the level LPR for the
    first time)

    Once parked, the car will wait 100-10000ms before departing the level
    (and triggering the level LPR of the second time)

    It then takes the car a further 10ms to drive to a random exit and
    trigger the exit LPR.

    Every 1-5ms the temperature on each level will change to a random value

MEMORY
    The simulator must create a shared memory segment named PARKING.

    The segment is 2920 bytes in size and must be created every time the
    program runs (overwrite existing)
*/
#include <fcntl.h>
#include <pthread.h>
#include <semaphore.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>

#include "./header.h"

#define SHARE_NAME "PARKING"
#define SHARE_SIZE 2920
#define ENTRANCES 5
#define EXITS 5
#define LEVELS 5

// global variables
int shm_fd;
void *ptr;

int thread_id;

pthread_t *simulate_car;

const char charset[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
const char number[] = "1234567890";
char temp[6];
char *license_plate[100];

// attributes for mutex and cond
pthread_mutexattr_t m_shared;
pthread_condattr_t c_shared;

// initalize hash tables for storing plates from txt
bool store_plates() {
    FILE *f = fopen("plates.txt", "r");
    int i = 0;
    // put value in array char
    while (fgets(temp, 8, f)) {
        temp[strcspn(temp, "\n")] = 0;
        license_plate[i] = malloc(6);
        strcpy(license_plate[i], temp);
        i++;
    }
    fclose(f);
    return EXIT_SUCCESS;
}

static char *rand_string(char *str, size_t size) {
    if (size) {
        --size;
        for (size_t n = 0; n < 3; n++) {
            int key = rand() % (int)(sizeof number - 1);
            str[n] = number[key];
        }
        for (size_t n = 0; n < 3; n++) {
            int key = rand() % (int)(sizeof charset - 1);
            str[n + 3] = charset[key];
        }
    }
    return str;
}

// random license plate
char *rand_string_alloc(size_t size) {
    char *s = malloc(size);
    if (s) {
        rand_string(s, size);
    }
    return s;
}

car_t *random_cars(bool flag) {
    // create car
    car_t *car = malloc(sizeof(car_t));
    // random license
    // if flag false, create a random license plate
    if (flag == false) {
        char *license = rand_string_alloc(6);
        strcpy(car->license, license);
    }
    // if true, get the license plate that is allowed
    else {
        int i = rand() % 100;
        char *license = license_plate[i];
        strcpy(car->license, license);
    }
    // random entrance id (1-5)
    // car->entrance_id = rand() % (int)(5);
    car->entrance_id = 0;

    // random exit id (1-5)
    car->exit_id = rand() % (int)(5);

    // random parking time (100 - 100000ms)
    car->parking_time = ((int)100 + (rand() % (int)(9901))) * 1000;

    return car;
}

void trigger_en_lpr(car_t car) {
    // get info on car
    int floor = car.entrance_id;
    struct LPR *lpr = ptr + (sizeof(en_t) * floor);

    // lock mutex
    pthread_mutex_lock(&lpr->m);

    printf("ENTRANCE %d LPR TRIGGERED!\n", floor);
    // signal to start reading
    // pthread_cond_signal((pthread_cond_t *)((void *)ptr) + 40 + (floor * sizeof(en_t)));
    pthread_cond_signal(&lpr->c);
    strcpy(lpr->license, car.license);

    // unlock the mutex
    pthread_mutex_unlock(&lpr->m);
}

void *simulate_car_handler(void *arg) {
    car_t *car = arg;
    LPR_t *lv_lpr = ptr + 0 * sizeof(lv_t) + 2400;
    // sleep(1);
    // wait for the car to finish parking
    usleep(car->parking_time);
    strcpy(lv_lpr->license, car->license);
    // signal the lv lpr that the car want to exit
    pthread_cond_signal(&lv_lpr->c);

    // remove the car from simulation
    free(car);
}

void *generate_car_handler(void *arg) {
    bool flag = true;
    // do forever
    for (;;) {
        // create a car
        car_t *car = random_cars(flag);
        // assign cars to the entrance
        int floor = car->entrance_id;
        struct LPR *lpr = ptr + (sizeof(en_t) * floor);
        // lock the mutex
        pthread_mutex_lock(&lpr->m);
        printf("ENTRANCE %d LPR TRIGGERED!\n", floor + 1);
        // the car is at the entrance
        strcpy(lpr->license, car->license);
        // unlock the mutex2
        pthread_mutex_unlock(&lpr->m);
        // wait 2ms for the lpr entrance to read
        usleep(2 * 1000);
        // signal the lpr entrance to read
        pthread_cond_signal(&lpr->c);

        pthread_mutex_lock(&lpr->m);
        // usleep(10 * 1000);
        // get the ist info
        info_sign_t *ist = ptr + (sizeof(en_t) * floor) + 192;
        boomgate_t *bg = ptr + (sizeof(en_t) * floor) + 96;
        // pthread_cond_init(&ist->c, NULL);
        pthread_cond_wait(&ist->c, &lpr->m);
        if (ist->s == 'X' || ist->s == 'F') {
            printf("this car cannot be parked! %d\n", ist->s);
            // this car is removed
            free(car);
            flag = !flag;
        } else {
            printf("this car can be parked on level %c! \n", ist->s);
            pthread_t exit_car;
            car_t *accepted_car;

            accepted_car = malloc(sizeof(car_t));
            strcpy(accepted_car->license, car->license);
            accepted_car->parking_time = car->parking_time;
            accepted_car->lv = ist->s;
            // wait for the gate to open

            pthread_cond_wait(&bg->c, &lpr->m);
            // take 10ms for car to park in the car park
            // usleep(10 * 1000);
            // thread for car to be exited
            pthread_create(&(exit_car), NULL, simulate_car_handler, accepted_car);
            free(car);
            flag = !flag;
            // wait for the gate to close
            pthread_cond_wait(&bg->c, &lpr->m);
            // usleep(20)
        }
        pthread_mutex_unlock(&lpr->m);

        // sleep(1);
    }
}

// Called to handle lvl lpr input
void read_lvl_lpr(void *arg) {
    // this function is ca
}

int main(int argc, char **argv) {
    // get the shared objects
    shm_fd = shm_open(SHARE_NAME, O_CREAT | O_RDWR, S_IRWXU);
    // set the size
    ftruncate(shm_fd, SHARE_SIZE);
    // get the address and save it in the pointer
    ptr = (void *)mmap(0, SHARE_SIZE, PROT_WRITE | PROT_READ, MAP_SHARED, shm_fd, 0);

    // store plates
    store_plates();

    // make sure the pthread mutex is sharable by creating attr
    pthread_mutexattr_init(&m_shared);
    pthread_mutexattr_setpshared(&m_shared, PTHREAD_PROCESS_SHARED);
    // make sure the cthread mutex is sharable by creating attr
    pthread_condattr_init(&c_shared);
    pthread_condattr_setpshared(&c_shared, PTHREAD_PROCESS_SHARED);

    simulate_car = malloc(sizeof(pthread_t) * 1);
    thread_id = 1;
    // // initializes mutexes and conditions
    // for (int i = 0; i < 1; i++) {
    //     // address for entrance, exits and levels; and store it in *en
    //     int en_addr = i * sizeof(en_t);
    //     int ex_addr = i * sizeof(exit_t) + 1440;
    //     int lv_addr = i * sizeof(lv_t) + 2400;

    //     // lpr
    //     LPR_t *en_lpr = ptr + en_addr;
    //     LPR_t *ex_lpr = ptr + ex_addr;
    //     LPR_t *lv_lpr = ptr + lv_addr;

    //     // boomgate
    //     boomgate_t *en_bg = ptr + en_addr + 96;
    //     boomgate_t *ex_bg = ptr + ex_addr + 136;

    //     // ist
    //     info_sign_t *ist = ptr + en_addr + 192;

    //     // int a = get_lv(lv_lpr);
    //     // printf("%d\n", a);

    //     // printf("%ld\n", ((long int)lv_lpr - (long int)lv_lpr1) / sizeof(lv_t));
    //     // mutexes and cond for lpr
    //     pthread_mutex_init(&en_lpr->m, &m_shared);
    //     pthread_mutex_init(&ex_lpr->m, &m_shared);
    //     pthread_mutex_init(&lv_lpr->m, &m_shared);

    //     pthread_cond_init(&en_lpr->c, &c_shared);
    //     pthread_cond_init(&ex_lpr->c, &c_shared);
    //     pthread_cond_init(&lv_lpr->c, &c_shared);

    //     // mutexes and cond for bg
    //     pthread_mutex_init(&en_bg->m, &m_shared);
    //     pthread_mutex_init(&ex_bg->m, &m_shared);

    //     pthread_cond_init(&en_bg->c, &c_shared);
    //     pthread_cond_init(&ex_bg->c, &c_shared);

    //     // mutexes and cond for ist
    //     pthread_mutex_init(&ist->m, &m_shared);
    //     pthread_cond_init(&ist->c, &c_shared);

    pthread_create(simulate_car, NULL, generate_car_handler, (void *)&thread_id);
    // }

    // create 1 threads for simulating the car

    sleep(100);
    *(char *)(ptr + 2919) = 0;

    free(simulate_car);
    return 0;
}
